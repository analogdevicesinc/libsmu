<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libsmu: smu::Session Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libsmu
   &#160;<span id="projectnumber">1.0.4</span>
   </div>
   <div id="projectbrief">Library for interfacing with ADALM1000 devices</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>smu</b></li><li class="navelem"><a class="el" href="classsmu_1_1Session.html">Session</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classsmu_1_1Session-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">smu::Session Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Generic session class.  
 <a href="classsmu_1_1Session.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="libsmu_8hpp_source.html">libsmu.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acc70d95d0c0e95be86eb5f4e1969b178"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#acc70d95d0c0e95be86eb5f4e1969b178">scan</a> ()</td></tr>
<tr class="memdesc:acc70d95d0c0e95be86eb5f4e1969b178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan system for all supported devices. Updates the list of available, supported devices for the session (m_available_devices).  <a href="#acc70d95d0c0e95be86eb5f4e1969b178">More...</a><br /></td></tr>
<tr class="separator:acc70d95d0c0e95be86eb5f4e1969b178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7dc39877f9bd1c00e76fabc149c3d84"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#ac7dc39877f9bd1c00e76fabc149c3d84">add</a> (<a class="el" href="classsmu_1_1Device.html">Device</a> *device)</td></tr>
<tr class="memdesc:ac7dc39877f9bd1c00e76fabc149c3d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a device to the session. This method may not be called while the session is active.  <a href="#ac7dc39877f9bd1c00e76fabc149c3d84">More...</a><br /></td></tr>
<tr class="separator:ac7dc39877f9bd1c00e76fabc149c3d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08380597da395595965e7c118e96619b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a08380597da395595965e7c118e96619b">add_all</a> ()</td></tr>
<tr class="memdesc:a08380597da395595965e7c118e96619b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shim to scan and add all available devices to a session. This method may not be called while the session is active.  <a href="#a08380597da395595965e7c118e96619b">More...</a><br /></td></tr>
<tr class="separator:a08380597da395595965e7c118e96619b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d93e9017b5f1243b58bf156fd79ebde"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a9d93e9017b5f1243b58bf156fd79ebde">remove</a> (<a class="el" href="classsmu_1_1Device.html">Device</a> *device, bool <a class="el" href="classsmu_1_1Session.html#a4483e84ebed73d4e62e3730306c73be3">detached</a>=false)</td></tr>
<tr class="memdesc:a9d93e9017b5f1243b58bf156fd79ebde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a device from the session.  <a href="#a9d93e9017b5f1243b58bf156fd79ebde">More...</a><br /></td></tr>
<tr class="separator:a9d93e9017b5f1243b58bf156fd79ebde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa841c59608d90d7127950faa17b185f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#aa841c59608d90d7127950faa17b185f9">destroy</a> (<a class="el" href="classsmu_1_1Device.html">Device</a> *device)</td></tr>
<tr class="memdesc:aa841c59608d90d7127950faa17b185f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a device from the list of available devices.  <a href="#aa841c59608d90d7127950faa17b185f9">More...</a><br /></td></tr>
<tr class="separator:aa841c59608d90d7127950faa17b185f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d0ff506aeabbd8608c92ec65131df4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#af2d0ff506aeabbd8608c92ec65131df4">configure</a> (uint32_t sampleRate=0)</td></tr>
<tr class="memdesc:af2d0ff506aeabbd8608c92ec65131df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the session's sample rate.  <a href="#af2d0ff506aeabbd8608c92ec65131df4">More...</a><br /></td></tr>
<tr class="separator:af2d0ff506aeabbd8608c92ec65131df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c7a2ba5e6dac8a03ba3ada7298758b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a48c7a2ba5e6dac8a03ba3ada7298758b">run</a> (uint64_t samples)</td></tr>
<tr class="memdesc:a48c7a2ba5e6dac8a03ba3ada7298758b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the currently configured capture and wait for it to complete.  <a href="#a48c7a2ba5e6dac8a03ba3ada7298758b">More...</a><br /></td></tr>
<tr class="separator:a48c7a2ba5e6dac8a03ba3ada7298758b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b6455d0931116a6cbe032de3939a4e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a50b6455d0931116a6cbe032de3939a4e">start</a> (uint64_t samples)</td></tr>
<tr class="memdesc:a50b6455d0931116a6cbe032de3939a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the currently configured capture, but do not wait for it to complete.  <a href="#a50b6455d0931116a6cbe032de3939a4e">More...</a><br /></td></tr>
<tr class="separator:a50b6455d0931116a6cbe032de3939a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2c6b8161896fa5e3af34e62ec32f0d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a8e2c6b8161896fa5e3af34e62ec32f0d">cancel</a> ()</td></tr>
<tr class="memdesc:a8e2c6b8161896fa5e3af34e62ec32f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel capture and block waiting for it to complete.  <a href="#a8e2c6b8161896fa5e3af34e62ec32f0d">More...</a><br /></td></tr>
<tr class="separator:a8e2c6b8161896fa5e3af34e62ec32f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4fc6bf82a0b11fa8b824136b36cdab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a0a4fc6bf82a0b11fa8b824136b36cdab">cancelled</a> ()</td></tr>
<tr class="memdesc:a0a4fc6bf82a0b11fa8b824136b36cdab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the cancellation status of a session.  <a href="#a0a4fc6bf82a0b11fa8b824136b36cdab">More...</a><br /></td></tr>
<tr class="separator:a0a4fc6bf82a0b11fa8b824136b36cdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829cd01f26920509862a4043eff37efc"><td class="memItemLeft" align="right" valign="top"><a id="a829cd01f26920509862a4043eff37efc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a829cd01f26920509862a4043eff37efc">flush</a> ()</td></tr>
<tr class="memdesc:a829cd01f26920509862a4043eff37efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the read and write queues for all devices in a session. <br /></td></tr>
<tr class="separator:a829cd01f26920509862a4043eff37efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5085bea3c93aab6adbfdda80a9ddfc5c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a5085bea3c93aab6adbfdda80a9ddfc5c">scan_samba_devs</a> (std::vector&lt; libusb_device * &gt; &amp;samba_devs)</td></tr>
<tr class="memdesc:a5085bea3c93aab6adbfdda80a9ddfc5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan system for devices in SAM-BA mode.  <a href="#a5085bea3c93aab6adbfdda80a9ddfc5c">More...</a><br /></td></tr>
<tr class="separator:a5085bea3c93aab6adbfdda80a9ddfc5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3131d287ba5c5a646530aeb1b92ace65"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a3131d287ba5c5a646530aeb1b92ace65">flash_firmware</a> (std::string file, std::vector&lt; <a class="el" href="classsmu_1_1Device.html">Device</a> * &gt; devices={})</td></tr>
<tr class="memdesc:a3131d287ba5c5a646530aeb1b92ace65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update firmware for the target device(s).  <a href="#a3131d287ba5c5a646530aeb1b92ace65">More...</a><br /></td></tr>
<tr class="separator:a3131d287ba5c5a646530aeb1b92ace65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdbec2e66e9478ca83c3d4c88a5e0cd"><td class="memItemLeft" align="right" valign="top"><a id="afcdbec2e66e9478ca83c3d4c88a5e0cd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#afcdbec2e66e9478ca83c3d4c88a5e0cd">completion</a> ()</td></tr>
<tr class="memdesc:afcdbec2e66e9478ca83c3d4c88a5e0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal: Called by devices on the USB thread when they are complete. <br /></td></tr>
<tr class="separator:afcdbec2e66e9478ca83c3d4c88a5e0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0e885ab8d46fc1793a75c35c5ec6f7"><td class="memItemLeft" align="right" valign="top"><a id="abf0e885ab8d46fc1793a75c35c5ec6f7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#abf0e885ab8d46fc1793a75c35c5ec6f7">handle_error</a> (int status, const char *tag)</td></tr>
<tr class="memdesc:abf0e885ab8d46fc1793a75c35c5ec6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal: Called by devices on the USB thread when a device encounters an error. <br /></td></tr>
<tr class="separator:abf0e885ab8d46fc1793a75c35c5ec6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab25f187c532e0654019fff37865f935"><td class="memItemLeft" align="right" valign="top"><a id="aab25f187c532e0654019fff37865f935"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#aab25f187c532e0654019fff37865f935">attached</a> (libusb_device *usb_dev)</td></tr>
<tr class="memdesc:aab25f187c532e0654019fff37865f935"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal: Called by device attach events on the USB thread. <br /></td></tr>
<tr class="separator:aab25f187c532e0654019fff37865f935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4483e84ebed73d4e62e3730306c73be3"><td class="memItemLeft" align="right" valign="top"><a id="a4483e84ebed73d4e62e3730306c73be3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a4483e84ebed73d4e62e3730306c73be3">detached</a> (libusb_device *usb_dev)</td></tr>
<tr class="memdesc:a4483e84ebed73d4e62e3730306c73be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal: Called by device detach events on the USB thread. <br /></td></tr>
<tr class="separator:a4483e84ebed73d4e62e3730306c73be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832c26a8729f4acb3cc0df399f515896"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a832c26a8729f4acb3cc0df399f515896">end</a> ()</td></tr>
<tr class="memdesc:a832c26a8729f4acb3cc0df399f515896"><td class="mdescLeft">&#160;</td><td class="mdescRight">For noncontinuous sessions, block until all devices have completed, then turn off the devices. Continuous sessions don't wait for completion and instead proceed with turning off the devices after canceling the session.  <a href="#a832c26a8729f4acb3cc0df399f515896">More...</a><br /></td></tr>
<tr class="separator:a832c26a8729f4acb3cc0df399f515896"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a717a8ea397e5aebc16800737bfe29814"><td class="memItemLeft" align="right" valign="top"><a id="a717a8ea397e5aebc16800737bfe29814"></a>
std::vector&lt; <a class="el" href="classsmu_1_1Device.html">Device</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a717a8ea397e5aebc16800737bfe29814">m_available_devices</a></td></tr>
<tr class="memdesc:a717a8ea397e5aebc16800737bfe29814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devices that are present on the system. Note that these devices consist of all supported devices currently recognized on the system; however, the devices aren't necessarily bound to a session. In order to add devices to a session, <a class="el" href="classsmu_1_1Session.html#ac7dc39877f9bd1c00e76fabc149c3d84" title="Add a device to the session. This method may not be called while the session is active.">add()</a> must be used. <br /></td></tr>
<tr class="separator:a717a8ea397e5aebc16800737bfe29814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed604b80d9b49ee18dbcbbb3d8921d0"><td class="memItemLeft" align="right" valign="top"><a id="a1ed604b80d9b49ee18dbcbbb3d8921d0"></a>
std::set&lt; <a class="el" href="classsmu_1_1Device.html">Device</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a1ed604b80d9b49ee18dbcbbb3d8921d0">m_devices</a></td></tr>
<tr class="memdesc:a1ed604b80d9b49ee18dbcbbb3d8921d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devices that are part of this session. These devices will be started when <a class="el" href="classsmu_1_1Session.html#a50b6455d0931116a6cbe032de3939a4e" title="Start the currently configured capture, but do not wait for it to complete.">start()</a> is called. Use <code><a class="el" href="classsmu_1_1Session.html#ac7dc39877f9bd1c00e76fabc149c3d84" title="Add a device to the session. This method may not be called while the session is active.">add()</a></code> and <code><a class="el" href="classsmu_1_1Session.html#a9d93e9017b5f1243b58bf156fd79ebde" title="Remove a device from the session.">remove()</a></code> to manipulate this set. <br /></td></tr>
<tr class="separator:a1ed604b80d9b49ee18dbcbbb3d8921d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b886bf85b1522b0a070585dc0d1717"><td class="memItemLeft" align="right" valign="top"><a id="a75b886bf85b1522b0a070585dc0d1717"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a75b886bf85b1522b0a070585dc0d1717">m_active_devices</a></td></tr>
<tr class="memdesc:a75b886bf85b1522b0a070585dc0d1717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of devices currently streaming samples. <br /></td></tr>
<tr class="separator:a75b886bf85b1522b0a070585dc0d1717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece2522fe453d4e2db0b3a5e566a6497"><td class="memItemLeft" align="right" valign="top"><a id="aece2522fe453d4e2db0b3a5e566a6497"></a>
std::map&lt; libusb_device *, libusb_device_handle * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#aece2522fe453d4e2db0b3a5e566a6497">m_deviceHandles</a></td></tr>
<tr class="memdesc:aece2522fe453d4e2db0b3a5e566a6497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map for the workaround described in session.cpp -&gt; <a class="el" href="classsmu_1_1Session.html#a7b24689fe070fd755d8ae202a3a78343" title="Identify devices supported by libsmu.">probe_device()</a>. <br /></td></tr>
<tr class="separator:aece2522fe453d4e2db0b3a5e566a6497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98abe9036a8ccf4e369a26d296b1942c"><td class="memItemLeft" align="right" valign="top"><a id="a98abe9036a8ccf4e369a26d296b1942c"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a98abe9036a8ccf4e369a26d296b1942c">m_queue_size</a> = 100000</td></tr>
<tr class="memdesc:a98abe9036a8ccf4e369a26d296b1942c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of input/output sample queues for every device. Alter this if necessary to make continuous data flow work for the target usage. The default is approximately 100ms worth of samples at the maximum sampling rate. Note that must be changed before devices are added to a session otherwise they'll use the default. <br /></td></tr>
<tr class="separator:a98abe9036a8ccf4e369a26d296b1942c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a57501ec06fbfda3f4963531cedc4e"><td class="memItemLeft" align="right" valign="top"><a id="a15a57501ec06fbfda3f4963531cedc4e"></a>
std::function&lt; void(unsigned)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a15a57501ec06fbfda3f4963531cedc4e">m_completion_callback</a></td></tr>
<tr class="memdesc:a15a57501ec06fbfda3f4963531cedc4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback run via the USB thread on session completion. Called with the current value of m_cancellation as an argument, i.e. if the parameter is non-zero we are waiting to complete a cancelled session. <br /></td></tr>
<tr class="separator:a15a57501ec06fbfda3f4963531cedc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93394ce75b3755b86eacc58ce36146a"><td class="memItemLeft" align="right" valign="top"><a id="ad93394ce75b3755b86eacc58ce36146a"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#ad93394ce75b3755b86eacc58ce36146a">m_sample_rate</a> = 0</td></tr>
<tr class="memdesc:ad93394ce75b3755b86eacc58ce36146a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsmu_1_1Session.html" title="Generic session class.">Session</a> sample rate. <br /></td></tr>
<tr class="separator:ad93394ce75b3755b86eacc58ce36146a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a380662e026f2e5aa5833f9adda6b7"><td class="memItemLeft" align="right" valign="top"><a id="aa7a380662e026f2e5aa5833f9adda6b7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#aa7a380662e026f2e5aa5833f9adda6b7">m_continuous</a> = false</td></tr>
<tr class="memdesc:aa7a380662e026f2e5aa5833f9adda6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag used to determine if a session is in continuous mode or not. <br /></td></tr>
<tr class="separator:aa7a380662e026f2e5aa5833f9adda6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7b24689fe070fd755d8ae202a3a78343"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsmu_1_1Device.html">Device</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a7b24689fe070fd755d8ae202a3a78343">probe_device</a> (libusb_device *usb_dev)</td></tr>
<tr class="memdesc:a7b24689fe070fd755d8ae202a3a78343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify devices supported by libsmu.  <a href="#a7b24689fe070fd755d8ae202a3a78343">More...</a><br /></td></tr>
<tr class="separator:a7b24689fe070fd755d8ae202a3a78343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45701c4bfc8b082c819191dacd4a67b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsmu_1_1Device.html">Device</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a45701c4bfc8b082c819191dacd4a67b6">find_existing_device</a> (libusb_device *usb_dev)</td></tr>
<tr class="memdesc:a45701c4bfc8b082c819191dacd4a67b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an existing, available device.  <a href="#a45701c4bfc8b082c819191dacd4a67b6">More...</a><br /></td></tr>
<tr class="separator:a45701c4bfc8b082c819191dacd4a67b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae6e0c6984c7567b31b7a7f544b27f9c4"><td class="memItemLeft" align="right" valign="top"><a id="ae6e0c6984c7567b31b7a7f544b27f9c4"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#ae6e0c6984c7567b31b7a7f544b27f9c4">m_cancellation</a> = 0</td></tr>
<tr class="memdesc:ae6e0c6984c7567b31b7a7f544b27f9c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag used to cancel all pending USB transactions for devices in a session. <br /></td></tr>
<tr class="separator:ae6e0c6984c7567b31b7a7f544b27f9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d36179ca4dcc9859025e5a97858196c"><td class="memItemLeft" align="right" valign="top"><a id="a0d36179ca4dcc9859025e5a97858196c"></a>
std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a0d36179ca4dcc9859025e5a97858196c">m_usb_thread_loop</a></td></tr>
<tr class="memdesc:a0d36179ca4dcc9859025e5a97858196c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for controlling USB event handling. USB event handling loop will be run while m_usb_thread_loop is true. <br /></td></tr>
<tr class="separator:a0d36179ca4dcc9859025e5a97858196c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f32749c5d2837c433ca0817e6a5e08"><td class="memItemLeft" align="right" valign="top"><a id="ab2f32749c5d2837c433ca0817e6a5e08"></a>
std::thread&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#ab2f32749c5d2837c433ca0817e6a5e08">m_usb_thread</a></td></tr>
<tr class="memdesc:ab2f32749c5d2837c433ca0817e6a5e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB thread handling pending events in blocking mode. <br /></td></tr>
<tr class="separator:ab2f32749c5d2837c433ca0817e6a5e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4570213847cccd9021c1e51b72fec27"><td class="memItemLeft" align="right" valign="top"><a id="ac4570213847cccd9021c1e51b72fec27"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#ac4570213847cccd9021c1e51b72fec27">m_lock</a></td></tr>
<tr class="memdesc:ac4570213847cccd9021c1e51b72fec27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock for session completion. <br /></td></tr>
<tr class="separator:ac4570213847cccd9021c1e51b72fec27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ca39f64d0f74e80a8d3e6e7e14e949"><td class="memItemLeft" align="right" valign="top"><a id="a21ca39f64d0f74e80a8d3e6e7e14e949"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a21ca39f64d0f74e80a8d3e6e7e14e949">m_lock_devlist</a></td></tr>
<tr class="memdesc:a21ca39f64d0f74e80a8d3e6e7e14e949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock for the available device list. All code that references m_available_devices needs to acquire this lock before accessing it. <br /></td></tr>
<tr class="separator:a21ca39f64d0f74e80a8d3e6e7e14e949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc155db0e9ead7132fa8f92a66f0361"><td class="memItemLeft" align="right" valign="top"><a id="a3dc155db0e9ead7132fa8f92a66f0361"></a>
std::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a3dc155db0e9ead7132fa8f92a66f0361">m_completion</a></td></tr>
<tr class="memdesc:a3dc155db0e9ead7132fa8f92a66f0361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks on m_lock until session completion is finished. <br /></td></tr>
<tr class="separator:a3dc155db0e9ead7132fa8f92a66f0361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14d22795713d4489ac106c2a31805b1"><td class="memItemLeft" align="right" valign="top"><a id="ad14d22795713d4489ac106c2a31805b1"></a>
libusb_context *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#ad14d22795713d4489ac106c2a31805b1">m_usb_ctx</a></td></tr>
<tr class="memdesc:ad14d22795713d4489ac106c2a31805b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">libusb context related with a session. This allows for segregating libusb usage so external users can also use libusb without interfering with internal usage. <br /></td></tr>
<tr class="separator:ad14d22795713d4489ac106c2a31805b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae096fe66b23a1c9c90c3da34a333e46"><td class="memItemLeft" align="right" valign="top"><a id="aae096fe66b23a1c9c90c3da34a333e46"></a>
libusb_hotplug_callback_handle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#aae096fe66b23a1c9c90c3da34a333e46">m_usb_cb</a></td></tr>
<tr class="memdesc:aae096fe66b23a1c9c90c3da34a333e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">libusb hotplug callback handle. <br /></td></tr>
<tr class="separator:aae096fe66b23a1c9c90c3da34a333e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f99b1997d3a4453951837ee87d85894"><td class="memItemLeft" align="right" valign="top"><a id="a7f99b1997d3a4453951837ee87d85894"></a>
std::vector&lt; std::function&lt; void(<a class="el" href="classsmu_1_1Device.html">Device</a> *device)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a7f99b1997d3a4453951837ee87d85894">m_hotplug_attach_callbacks</a></td></tr>
<tr class="memdesc:a7f99b1997d3a4453951837ee87d85894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callbacks called on the USB thread when a device is removed from the system. <br /></td></tr>
<tr class="separator:a7f99b1997d3a4453951837ee87d85894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d13578b2ab948da042b9cada2c976e0"><td class="memItemLeft" align="right" valign="top"><a id="a0d13578b2ab948da042b9cada2c976e0"></a>
std::vector&lt; std::function&lt; void(<a class="el" href="classsmu_1_1Device.html">Device</a> *device)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a0d13578b2ab948da042b9cada2c976e0">m_hotplug_detach_callbacks</a></td></tr>
<tr class="memdesc:a0d13578b2ab948da042b9cada2c976e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callbacks called on the USB thread when a device is plugged into the system. <br /></td></tr>
<tr class="separator:a0d13578b2ab948da042b9cada2c976e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Generic session class. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ac7dc39877f9bd1c00e76fabc149c3d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7dc39877f9bd1c00e76fabc149c3d84">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int smu::Session::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsmu_1_1Device.html">Device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a device to the session. This method may not be called while the session is active. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to be added to the session. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned. </dd>
<dd>
On error, a negative errno code is returned. </dd></dl>

</div>
</div>
<a id="a08380597da395595965e7c118e96619b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08380597da395595965e7c118e96619b">&#9670;&nbsp;</a></span>add_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int smu::Session::add_all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shim to scan and add all available devices to a session. This method may not be called while the session is active. </p>
<dl class="section return"><dt>Returns</dt><dd>On success, the number of devices added to the session is returned. </dd>
<dd>
On error, a negative errno code is returned. </dd></dl>

</div>
</div>
<a id="a8e2c6b8161896fa5e3af34e62ec32f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2c6b8161896fa5e3af34e62ec32f0d">&#9670;&nbsp;</a></span>cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int smu::Session::cancel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel capture and block waiting for it to complete. </p>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned. </dd>
<dd>
On error, -1 is returned. Note that the cancellation process will stop on the first device that fails to cancel its capture. </dd></dl>

</div>
</div>
<a id="a0a4fc6bf82a0b11fa8b824136b36cdab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4fc6bf82a0b11fa8b824136b36cdab">&#9670;&nbsp;</a></span>cancelled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool smu::Session::cancelled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the cancellation status of a session. </p>
<dl class="section return"><dt>Returns</dt><dd>True, if the session has been cancelled (usually from explicitly calling <a class="el" href="classsmu_1_1Session.html#a8e2c6b8161896fa5e3af34e62ec32f0d" title="Cancel capture and block waiting for it to complete.">cancel()</a> or cancelled USB transactions). </dd>
<dd>
False, if the session hasn't been started, is running, or has been stopped successfully. </dd></dl>

</div>
</div>
<a id="af2d0ff506aeabbd8608c92ec65131df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d0ff506aeabbd8608c92ec65131df4">&#9670;&nbsp;</a></span>configure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int smu::Session::configure </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sampleRate</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the session's sample rate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampleRate</td><td>The requested sample rate for the session. Requesting a sample rate of 0 (the default) causes the session to use the first device's default sample rate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the configured sample rate is returned. </dd>
<dd>
On error, a negative errno code is returned. This method may not be called while the session is active. </dd></dl>

</div>
</div>
<a id="aa841c59608d90d7127950faa17b185f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa841c59608d90d7127950faa17b185f9">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int smu::Session::destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsmu_1_1Device.html">Device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a device from the list of available devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A device to be removed from the available list. Devices are automatically added to this list on attach. Devices must be removed from this list on detach. This method may not be called while the session is active. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned. </dd>
<dd>
On error, a negative errno code is returned. </dd></dl>

</div>
</div>
<a id="a832c26a8729f4acb3cc0df399f515896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832c26a8729f4acb3cc0df399f515896">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int smu::Session::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For noncontinuous sessions, block until all devices have completed, then turn off the devices. Continuous sessions don't wait for completion and instead proceed with turning off the devices after canceling the session. </p>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned. </dd>
<dd>
On error, a negative errno code is returned. </dd></dl>

</div>
</div>
<a id="a45701c4bfc8b082c819191dacd4a67b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45701c4bfc8b082c819191dacd4a67b6">&#9670;&nbsp;</a></span>find_existing_device()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsmu_1_1Device.html">Device</a>* smu::Session::find_existing_device </td>
          <td>(</td>
          <td class="paramtype">libusb_device *&#160;</td>
          <td class="paramname"><em>usb_dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find an existing, available device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">usb_dev</td><td>libusb device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the usb device relates to an existing, available device the <a class="el" href="classsmu_1_1Device.html" title="Generic device class.">Device</a> is returned, otherwise NULL is returned. </dd></dl>

</div>
</div>
<a id="a3131d287ba5c5a646530aeb1b92ace65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3131d287ba5c5a646530aeb1b92ace65">&#9670;&nbsp;</a></span>flash_firmware()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int smu::Session::flash_firmware </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsmu_1_1Device.html">Device</a> * &gt;&#160;</td>
          <td class="paramname"><em>devices</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update firmware for the target device(s). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>Path to firmware file. </td></tr>
    <tr><td class="paramname">devices</td><td>The device(s) targeted for updating. If empty or unset, all the attached devices in SAM-BA mode are updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the number of devices flashed is returned. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>for various USB failures causing aborted flashes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b24689fe070fd755d8ae202a3a78343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b24689fe070fd755d8ae202a3a78343">&#9670;&nbsp;</a></span>probe_device()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsmu_1_1Device.html">Device</a>* smu::Session::probe_device </td>
          <td>(</td>
          <td class="paramtype">libusb_device *&#160;</td>
          <td class="paramname"><em>usb_dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identify devices supported by libsmu. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">usb_dev</td><td>libusb device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the usb device relates to a supported device the <a class="el" href="classsmu_1_1Device.html" title="Generic device class.">Device</a> is returned, otherwise NULL is returned. </dd></dl>

</div>
</div>
<a id="a9d93e9017b5f1243b58bf156fd79ebde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d93e9017b5f1243b58bf156fd79ebde">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int smu::Session::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsmu_1_1Device.html">Device</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>detached</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a device from the session. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A device to be removed from the session. </td></tr>
    <tr><td class="paramname">detached</td><td>True if the device has already been detached from the system (defaults to false). This method may not be called while the session is active. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned. </dd>
<dd>
On error, a negative errno code is returned. </dd></dl>

</div>
</div>
<a id="a48c7a2ba5e6dac8a03ba3ada7298758b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c7a2ba5e6dac8a03ba3ada7298758b">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int smu::Session::run </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>samples</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the currently configured capture and wait for it to complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">samples</td><td>Number of samples to capture until we stop. If 0, run in continuous mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned. </dd>
<dd>
On error, a negative errno code is returned. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::system_error</td><td>of EBUSY if sample underflows/overflows have occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc70d95d0c0e95be86eb5f4e1969b178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc70d95d0c0e95be86eb5f4e1969b178">&#9670;&nbsp;</a></span>scan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int smu::Session::scan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scan system for all supported devices. Updates the list of available, supported devices for the session (m_available_devices). </p>
<dl class="section return"><dt>Returns</dt><dd>On success, the number of devices found is returned. </dd>
<dd>
On error, a negative errno code is returned. </dd></dl>

</div>
</div>
<a id="a5085bea3c93aab6adbfdda80a9ddfc5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5085bea3c93aab6adbfdda80a9ddfc5c">&#9670;&nbsp;</a></span>scan_samba_devs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int smu::Session::scan_samba_devs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; libusb_device * &gt; &amp;&#160;</td>
          <td class="paramname"><em>samba_devs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scan system for devices in SAM-BA mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">samba_devs</td><td>Vector of libusb devices in SAM-BA mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the number of devices found is returned. </dd>
<dd>
On error, a negative errno code is returned. </dd></dl>

</div>
</div>
<a id="a50b6455d0931116a6cbe032de3939a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b6455d0931116a6cbe032de3939a4e">&#9670;&nbsp;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int smu::Session::start </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>samples</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the currently configured capture, but do not wait for it to complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">samples</td><td>Number of samples to capture until we stop. If 0, run in continuous mode.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the number of samples actually captured will be the nearest multiple of the amount of samples per USB packet larger than the request amount of samples.</p>
<p>Once started, the only allowed <a class="el" href="classsmu_1_1Session.html" title="Generic session class.">Session</a> methods are <a class="el" href="classsmu_1_1Session.html#a8e2c6b8161896fa5e3af34e62ec32f0d" title="Cancel capture and block waiting for it to complete.">cancel()</a> and <a class="el" href="classsmu_1_1Session.html#a832c26a8729f4acb3cc0df399f515896" title="For noncontinuous sessions, block until all devices have completed, then turn off the devices....">end()</a> until the session has stopped.</p>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned. </dd>
<dd>
On error, a negative errno code is returned. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::system_error</td><td>of EBUSY if sample underflows/overflows have occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/vsts/work/1/s/include/libsmu/<a class="el" href="libsmu_8hpp_source.html">libsmu.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 11 2022 13:51:01 for libsmu by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
