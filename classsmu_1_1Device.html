<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libsmu: smu::Device Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libsmu
   &#160;<span id="projectnumber">1.0.4</span>
   </div>
   <div id="projectbrief">Library for interfacing with ADALM1000 devices</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>smu</b></li><li class="navelem"><a class="el" href="classsmu_1_1Device.html">Device</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classsmu_1_1Device-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">smu::Device Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Generic device class.  
 <a href="classsmu_1_1Device.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="libsmu_8hpp_source.html">libsmu.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a95f7b22c80405db976a265a33de0185c"><td class="memItemLeft" align="right" valign="top"><a id="a95f7b22c80405db976a265a33de0185c"></a>
virtual const <a class="el" href="structsl__device__info.html">sl_device_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#a95f7b22c80405db976a265a33de0185c">info</a> () const =0</td></tr>
<tr class="memdesc:a95f7b22c80405db976a265a33de0185c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the descriptor for the device. <br /></td></tr>
<tr class="separator:a95f7b22c80405db976a265a33de0185c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26289421ca32608872dc5cb381588734"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structsl__channel__info.html">sl_channel_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#a26289421ca32608872dc5cb381588734">channel_info</a> (unsigned channel) const =0</td></tr>
<tr class="memdesc:a26289421ca32608872dc5cb381588734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the descriptor for the specified channel.  <a href="#a26289421ca32608872dc5cb381588734">More...</a><br /></td></tr>
<tr class="separator:a26289421ca32608872dc5cb381588734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ecee69bc241b53855debf994abb6575"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classsmu_1_1Signal.html">Signal</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#a4ecee69bc241b53855debf994abb6575">signal</a> (unsigned channel, unsigned signal)=0</td></tr>
<tr class="memdesc:a4ecee69bc241b53855debf994abb6575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the specified signal.  <a href="#a4ecee69bc241b53855debf994abb6575">More...</a><br /></td></tr>
<tr class="separator:a4ecee69bc241b53855debf994abb6575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6721e35b65dfe67729991942d833fb9b"><td class="memItemLeft" align="right" valign="top"><a id="a6721e35b65dfe67729991942d833fb9b"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#a6721e35b65dfe67729991942d833fb9b">fwver_sem</a> (std::array&lt; unsigned, 3 &gt; &amp;components)=0</td></tr>
<tr class="memdesc:a6721e35b65dfe67729991942d833fb9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the array of firmware version components (major, minor, patch). Note that this method assumes semantic versioning so versions such as 2.06 will be coerced to 2.6.0, i.e. major=2, minor=6, patch=0. <br /></td></tr>
<tr class="separator:a6721e35b65dfe67729991942d833fb9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77ee34515d91d93ccbcd88afbb99641"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#ac77ee34515d91d93ccbcd88afbb99641">set_serial</a> (std::string serial=&quot;&quot;)=0</td></tr>
<tr class="memdesc:ac77ee34515d91d93ccbcd88afbb99641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a custom serial number for the device.  <a href="#ac77ee34515d91d93ccbcd88afbb99641">More...</a><br /></td></tr>
<tr class="separator:ac77ee34515d91d93ccbcd88afbb99641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a07260d2717082aa4ac21f2c8552a2e"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#a8a07260d2717082aa4ac21f2c8552a2e">set_mode</a> (unsigned channel, unsigned mode, bool restore=true)=0</td></tr>
<tr class="memdesc:a8a07260d2717082aa4ac21f2c8552a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the mode of the specified channel.  <a href="#a8a07260d2717082aa4ac21f2c8552a2e">More...</a><br /></td></tr>
<tr class="separator:a8a07260d2717082aa4ac21f2c8552a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404220bc4f248e5655b964667a14ad34"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#a404220bc4f248e5655b964667a14ad34">get_mode</a> (unsigned channel)=0</td></tr>
<tr class="memdesc:a404220bc4f248e5655b964667a14ad34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mode of the specified channel.  <a href="#a404220bc4f248e5655b964667a14ad34">More...</a><br /></td></tr>
<tr class="separator:a404220bc4f248e5655b964667a14ad34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af193dd5fee8276d148d495e55de7891e"><td class="memItemLeft" align="right" valign="top">virtual ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#af193dd5fee8276d148d495e55de7891e">read</a> (std::vector&lt; std::array&lt; float, 4 &gt;&gt; &amp;buf, size_t samples, int timeout=0, bool skipsamples=false)=0</td></tr>
<tr class="memdesc:af193dd5fee8276d148d495e55de7891e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all signal samples from a device.  <a href="#af193dd5fee8276d148d495e55de7891e">More...</a><br /></td></tr>
<tr class="separator:af193dd5fee8276d148d495e55de7891e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e43c4c950d69c406ea8e3f7c8a360f"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#a30e43c4c950d69c406ea8e3f7c8a360f">write</a> (std::vector&lt; float &gt; &amp;buf, unsigned channel, bool cyclic=false)=0</td></tr>
<tr class="memdesc:a30e43c4c950d69c406ea8e3f7c8a360f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to a specified channel of the device.  <a href="#a30e43c4c950d69c406ea8e3f7c8a360f">More...</a><br /></td></tr>
<tr class="separator:a30e43c4c950d69c406ea8e3f7c8a360f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bba2f1c12bf3e4ccb15ba5150019ee1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#a1bba2f1c12bf3e4ccb15ba5150019ee1">flush</a> (int channel, bool <a class="el" href="classsmu_1_1Device.html#af193dd5fee8276d148d495e55de7891e">read</a>=false)=0</td></tr>
<tr class="memdesc:a1bba2f1c12bf3e4ccb15ba5150019ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the read and selected channel write queue for a device.  <a href="#a1bba2f1c12bf3e4ccb15ba5150019ee1">More...</a><br /></td></tr>
<tr class="separator:a1bba2f1c12bf3e4ccb15ba5150019ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d035b18c9ae682c9cd651f94417274"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#ae0d035b18c9ae682c9cd651f94417274">ctrl_transfer</a> (unsigned bmRequestType, unsigned bRequest, unsigned wValue, unsigned wIndex, unsigned char *data, unsigned wLength, unsigned timeout)</td></tr>
<tr class="memdesc:ae0d035b18c9ae682c9cd651f94417274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a raw USB control transfer on the underlying USB device.  <a href="#ae0d035b18c9ae682c9cd651f94417274">More...</a><br /></td></tr>
<tr class="separator:ae0d035b18c9ae682c9cd651f94417274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaebb9455a2699d5f8dd38209291a67ba"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#aaebb9455a2699d5f8dd38209291a67ba">samba_mode</a> ()=0</td></tr>
<tr class="memdesc:aaebb9455a2699d5f8dd38209291a67ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force the device into SAM-BA bootloader mode.  <a href="#aaebb9455a2699d5f8dd38209291a67ba">More...</a><br /></td></tr>
<tr class="separator:aaebb9455a2699d5f8dd38209291a67ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a09813cae9a9026341fa47b694365c"><td class="memItemLeft" align="right" valign="top"><a id="ab4a09813cae9a9026341fa47b694365c"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#ab4a09813cae9a9026341fa47b694365c">get_default_rate</a> ()</td></tr>
<tr class="memdesc:ab4a09813cae9a9026341fa47b694365c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default sample rate. <br /></td></tr>
<tr class="separator:ab4a09813cae9a9026341fa47b694365c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3011b5d22927b5ff4e3dc6167c6aa8bf"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#a3011b5d22927b5ff4e3dc6167c6aa8bf">sync</a> ()=0</td></tr>
<tr class="memdesc:a3011b5d22927b5ff4e3dc6167c6aa8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare multi-device synchronization. Get current microframe index, set m_sof_start to be time in the future.  <a href="#a3011b5d22927b5ff4e3dc6167c6aa8bf">More...</a><br /></td></tr>
<tr class="separator:a3011b5d22927b5ff4e3dc6167c6aa8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07ab3a1657054cb572ce3c36e70609d"><td class="memItemLeft" align="right" valign="top"><a id="aa07ab3a1657054cb572ce3c36e70609d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#aa07ab3a1657054cb572ce3c36e70609d">lock</a> ()</td></tr>
<tr class="memdesc:aa07ab3a1657054cb572ce3c36e70609d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the device's mutex. This prevents this device's transfers from being processed. Hold only briefly, while modifying signal state. <br /></td></tr>
<tr class="separator:aa07ab3a1657054cb572ce3c36e70609d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14e11dc0cb616590e3a7497030860ed"><td class="memItemLeft" align="right" valign="top"><a id="af14e11dc0cb616590e3a7497030860ed"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#af14e11dc0cb616590e3a7497030860ed">unlock</a> ()</td></tr>
<tr class="memdesc:af14e11dc0cb616590e3a7497030860ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the device's mutex. Allows this device's transfers to be processed. <br /></td></tr>
<tr class="separator:af14e11dc0cb616590e3a7497030860ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036087f31acc01c3f617005c42d71087"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#a036087f31acc01c3f617005c42d71087">write_calibration</a> (const char *cal_file_name)</td></tr>
<tr class="memdesc:a036087f31acc01c3f617005c42d71087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the device calibration data into the EEPROM.  <a href="#a036087f31acc01c3f617005c42d71087">More...</a><br /></td></tr>
<tr class="separator:a036087f31acc01c3f617005c42d71087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0180ce13eefa23684373a87e4c8cb50e"><td class="memItemLeft" align="right" valign="top"><a id="a0180ce13eefa23684373a87e4c8cb50e"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#a0180ce13eefa23684373a87e4c8cb50e">read_calibration</a> ()=0</td></tr>
<tr class="memdesc:a0180ce13eefa23684373a87e4c8cb50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read device calibration data from the EEPROM. <br /></td></tr>
<tr class="separator:a0180ce13eefa23684373a87e4c8cb50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81f8e543c2d0ca1f28b61c7e5b056b1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#ae81f8e543c2d0ca1f28b61c7e5b056b1">calibration</a> (std::vector&lt; std::vector&lt; float &gt;&gt; *cal)=0</td></tr>
<tr class="memdesc:ae81f8e543c2d0ca1f28b61c7e5b056b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device calibration data from the EEPROM.  <a href="#ae81f8e543c2d0ca1f28b61c7e5b056b1">More...</a><br /></td></tr>
<tr class="separator:ae81f8e543c2d0ca1f28b61c7e5b056b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447cf709dfe1f5a596457cf45396e0ad"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#a447cf709dfe1f5a596457cf45396e0ad">set_led</a> (unsigned leds)=0</td></tr>
<tr class="memdesc:a447cf709dfe1f5a596457cf45396e0ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the leds states for device.  <a href="#a447cf709dfe1f5a596457cf45396e0ad">More...</a><br /></td></tr>
<tr class="separator:a447cf709dfe1f5a596457cf45396e0ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3abd2903b309bdc699300aacad201d9"><td class="memItemLeft" align="right" valign="top"><a id="aa3abd2903b309bdc699300aacad201d9"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#aa3abd2903b309bdc699300aacad201d9">set_adc_mux</a> (unsigned adc_mux)=0</td></tr>
<tr class="memdesc:aa3abd2903b309bdc699300aacad201d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">set adc mux mode <br /></td></tr>
<tr class="separator:aa3abd2903b309bdc699300aacad201d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a38d1491686b58b2b3cab0a72026021a0"><td class="memItemLeft" align="right" valign="top"><a id="a38d1491686b58b2b3cab0a72026021a0"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#a38d1491686b58b2b3cab0a72026021a0">m_hwver</a></td></tr>
<tr class="memdesc:a38d1491686b58b2b3cab0a72026021a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">hardware version <br /></td></tr>
<tr class="separator:a38d1491686b58b2b3cab0a72026021a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be63b2e4697ed19202dcdb1d565ec83"><td class="memItemLeft" align="right" valign="top"><a id="a6be63b2e4697ed19202dcdb1d565ec83"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#a6be63b2e4697ed19202dcdb1d565ec83">m_fwver</a></td></tr>
<tr class="memdesc:a6be63b2e4697ed19202dcdb1d565ec83"><td class="mdescLeft">&#160;</td><td class="mdescRight">firmware version <br /></td></tr>
<tr class="separator:a6be63b2e4697ed19202dcdb1d565ec83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbdd71d4dc87d3c5135ee049675ebac0"><td class="memItemLeft" align="right" valign="top"><a id="acbdd71d4dc87d3c5135ee049675ebac0"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#acbdd71d4dc87d3c5135ee049675ebac0">m_serial</a></td></tr>
<tr class="memdesc:acbdd71d4dc87d3c5135ee049675ebac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">serial number <br /></td></tr>
<tr class="separator:acbdd71d4dc87d3c5135ee049675ebac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c14565874163ac3fda5a719890da3e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#af0c14565874163ac3fda5a719890da3e">m_overcurrent</a> = 0</td></tr>
<tr class="memdesc:af0c14565874163ac3fda5a719890da3e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsmu_1_1Session.html" title="Generic session class.">Session</a> this device is associated with.  <a href="#af0c14565874163ac3fda5a719890da3e">More...</a><br /></td></tr>
<tr class="separator:af0c14565874163ac3fda5a719890da3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a91732d6485aff6e4081b276f1b2fda38"><td class="memItemLeft" align="right" valign="top"><a id="a91732d6485aff6e4081b276f1b2fda38"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#a91732d6485aff6e4081b276f1b2fda38">Device</a> (<a class="el" href="classsmu_1_1Session.html">Session</a> *s, libusb_device *usb_dev, libusb_device_handle *usb_handle, const char *hw_version, const char *fw_version, const char *serial)</td></tr>
<tr class="memdesc:a91732d6485aff6e4081b276f1b2fda38"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsmu_1_1Device.html" title="Generic device class.">Device</a> constructor. <br /></td></tr>
<tr class="separator:a91732d6485aff6e4081b276f1b2fda38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545df09d3ab5f36c92e980dbed7ca439"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#a545df09d3ab5f36c92e980dbed7ca439">claim</a> ()</td></tr>
<tr class="memdesc:a545df09d3ab5f36c92e980dbed7ca439"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsmu_1_1Device.html" title="Generic device class.">Device</a> claiming and initialization when a session adds this device.  <a href="#a545df09d3ab5f36c92e980dbed7ca439">More...</a><br /></td></tr>
<tr class="separator:a545df09d3ab5f36c92e980dbed7ca439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b93ae4bd2c06866ee922f005093e50"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#ae3b93ae4bd2c06866ee922f005093e50">release</a> ()</td></tr>
<tr class="memdesc:ae3b93ae4bd2c06866ee922f005093e50"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsmu_1_1Device.html" title="Generic device class.">Device</a> releasing when a session removes this device.  <a href="#ae3b93ae4bd2c06866ee922f005093e50">More...</a><br /></td></tr>
<tr class="separator:ae3b93ae4bd2c06866ee922f005093e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ef3f849eff9bf9be91104020c75d43"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#ab6ef3f849eff9bf9be91104020c75d43">configure</a> (uint32_t sampleRate)=0</td></tr>
<tr class="memdesc:ab6ef3f849eff9bf9be91104020c75d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configurization and initialization for device sampling.  <a href="#ab6ef3f849eff9bf9be91104020c75d43">More...</a><br /></td></tr>
<tr class="separator:ab6ef3f849eff9bf9be91104020c75d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268a9b03f25704e7026841a74c468759"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#a268a9b03f25704e7026841a74c468759">on</a> ()=0</td></tr>
<tr class="memdesc:a268a9b03f25704e7026841a74c468759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on power supplies and clear sampling state.  <a href="#a268a9b03f25704e7026841a74c468759">More...</a><br /></td></tr>
<tr class="separator:a268a9b03f25704e7026841a74c468759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a4d09c13f1b16453db49d919f79904"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#a65a4d09c13f1b16453db49d919f79904">off</a> ()=0</td></tr>
<tr class="memdesc:a65a4d09c13f1b16453db49d919f79904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop any current sample writes and stop capturing samples.  <a href="#a65a4d09c13f1b16453db49d919f79904">More...</a><br /></td></tr>
<tr class="separator:a65a4d09c13f1b16453db49d919f79904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75d9c8f05d40317c001a37181f09750"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#af75d9c8f05d40317c001a37181f09750">run</a> (uint64_t samples)=0</td></tr>
<tr class="memdesc:af75d9c8f05d40317c001a37181f09750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the device start sampling.  <a href="#af75d9c8f05d40317c001a37181f09750">More...</a><br /></td></tr>
<tr class="separator:af75d9c8f05d40317c001a37181f09750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8274c560c21b1e36713905b2dbba331e"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#a8274c560c21b1e36713905b2dbba331e">cancel</a> ()=0</td></tr>
<tr class="memdesc:a8274c560c21b1e36713905b2dbba331e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel all pending libusb transactions.  <a href="#a8274c560c21b1e36713905b2dbba331e">More...</a><br /></td></tr>
<tr class="separator:a8274c560c21b1e36713905b2dbba331e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aa7e58344b36c0625c5eb93506840ac33"><td class="memItemLeft" align="right" valign="top"><a id="aa7e58344b36c0625c5eb93506840ac33"></a>
<a class="el" href="classsmu_1_1Session.html">Session</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#aa7e58344b36c0625c5eb93506840ac33">m_session</a></td></tr>
<tr class="memdesc:aa7e58344b36c0625c5eb93506840ac33"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsmu_1_1Session.html" title="Generic session class.">Session</a> this device is associated with. <br /></td></tr>
<tr class="separator:aa7e58344b36c0625c5eb93506840ac33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dbc695b947e2e0377db568d0f23a729"><td class="memItemLeft" align="right" valign="top"><a id="a4dbc695b947e2e0377db568d0f23a729"></a>
libusb_device *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#a4dbc695b947e2e0377db568d0f23a729">m_usb_dev</a> = NULL</td></tr>
<tr class="memdesc:a4dbc695b947e2e0377db568d0f23a729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying libusb device. <br /></td></tr>
<tr class="separator:a4dbc695b947e2e0377db568d0f23a729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae359422e116be7e38d36616a753793c4"><td class="memItemLeft" align="right" valign="top"><a id="ae359422e116be7e38d36616a753793c4"></a>
libusb_device_handle *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#ae359422e116be7e38d36616a753793c4">m_usb</a> = NULL</td></tr>
<tr class="memdesc:ae359422e116be7e38d36616a753793c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying libusb device handle. <br /></td></tr>
<tr class="separator:ae359422e116be7e38d36616a753793c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa7aeec6ab96b740f3d23873b651eae"><td class="memItemLeft" align="right" valign="top"><a id="a5aa7aeec6ab96b740f3d23873b651eae"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#a5aa7aeec6ab96b740f3d23873b651eae">m_requested_sampleno</a> = 0</td></tr>
<tr class="memdesc:a5aa7aeec6ab96b740f3d23873b651eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cumulative sample number being handled for input. <br /></td></tr>
<tr class="separator:a5aa7aeec6ab96b740f3d23873b651eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd4978fa561acac3825b37fd471b518"><td class="memItemLeft" align="right" valign="top"><a id="a6cd4978fa561acac3825b37fd471b518"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#a6cd4978fa561acac3825b37fd471b518">m_in_sampleno</a> = 0</td></tr>
<tr class="memdesc:a6cd4978fa561acac3825b37fd471b518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current sample number being handled for input. <br /></td></tr>
<tr class="separator:a6cd4978fa561acac3825b37fd471b518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2750a75063d4a9a93f9d9918f8f5e91b"><td class="memItemLeft" align="right" valign="top"><a id="a2750a75063d4a9a93f9d9918f8f5e91b"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#a2750a75063d4a9a93f9d9918f8f5e91b">m_out_sampleno</a> = 0</td></tr>
<tr class="memdesc:a2750a75063d4a9a93f9d9918f8f5e91b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current sample number being submitted for output. <br /></td></tr>
<tr class="separator:a2750a75063d4a9a93f9d9918f8f5e91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe53bd238d873d01e3d919044ecb3178"><td class="memItemLeft" align="right" valign="top"><a id="abe53bd238d873d01e3d919044ecb3178"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#abe53bd238d873d01e3d919044ecb3178">m_write_timeout</a> = 100</td></tr>
<tr class="memdesc:abe53bd238d873d01e3d919044ecb3178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amount of time in milliseconds to wait before timing out write operations, defaults to 100 ms and is based on the configured sample rate. <br /></td></tr>
<tr class="separator:abe53bd238d873d01e3d919044ecb3178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7485427d56b58e948408684469409c"><td class="memItemLeft" align="right" valign="top"><a id="aab7485427d56b58e948408684469409c"></a>
std::recursive_mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Device.html#aab7485427d56b58e948408684469409c">m_state</a></td></tr>
<tr class="memdesc:aab7485427d56b58e948408684469409c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock for transfer state. <br /></td></tr>
<tr class="separator:aab7485427d56b58e948408684469409c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:afbdd63a566878ce30072e785ca7e7740"><td class="memItemLeft" align="right" valign="top"><a id="afbdd63a566878ce30072e785ca7e7740"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Session</b></td></tr>
<tr class="separator:afbdd63a566878ce30072e785ca7e7740"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Generic device class. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ae81f8e543c2d0ca1f28b61c7e5b056b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae81f8e543c2d0ca1f28b61c7e5b056b1">&#9670;&nbsp;</a></span>calibration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void smu::Device::calibration </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; float &gt;&gt; *&#160;</td>
          <td class="paramname"><em>cal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the device calibration data from the EEPROM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cal</td><td>A vector of vectors containing calibration values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8274c560c21b1e36713905b2dbba331e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8274c560c21b1e36713905b2dbba331e">&#9670;&nbsp;</a></span>cancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int smu::Device::cancel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel all pending libusb transactions. </p>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned. </dd>
<dd>
On error, a negative errno code is returned. </dd></dl>

</div>
</div>
<a id="a26289421ca32608872dc5cb381588734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26289421ca32608872dc5cb381588734">&#9670;&nbsp;</a></span>channel_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structsl__channel__info.html">sl_channel_info</a>* smu::Device::channel_info </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the descriptor for the specified channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>An unsigned integer relating to the requested channel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a545df09d3ab5f36c92e980dbed7ca439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a545df09d3ab5f36c92e980dbed7ca439">&#9670;&nbsp;</a></span>claim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int smu::Device::claim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classsmu_1_1Device.html" title="Generic device class.">Device</a> claiming and initialization when a session adds this device. </p>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned. </dd>
<dd>
On error, a negative errno code is returned. </dd></dl>

</div>
</div>
<a id="ab6ef3f849eff9bf9be91104020c75d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ef3f849eff9bf9be91104020c75d43">&#9670;&nbsp;</a></span>configure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int smu::Device::configure </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sampleRate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configurization and initialization for device sampling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampleRate</td><td>The requested sampling rate for the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the configured sample rate is returned. </dd>
<dd>
On error, a negative errno code is returned. </dd></dl>

</div>
</div>
<a id="ae0d035b18c9ae682c9cd651f94417274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d035b18c9ae682c9cd651f94417274">&#9670;&nbsp;</a></span>ctrl_transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int smu::Device::ctrl_transfer </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bmRequestType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>wValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>wIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>wLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a raw USB control transfer on the underlying USB device. </p>
<dl class="section return"><dt>Returns</dt><dd>Passes through the return value of the underlying libusb_control_transfer method. See the libusb_control_transfer() docs for parameter descriptions. </dd></dl>

</div>
</div>
<a id="a1bba2f1c12bf3e4ccb15ba5150019ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bba2f1c12bf3e4ccb15ba5150019ee1">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void smu::Device::flush </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>read</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flush the read and selected channel write queue for a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Channel to flush the write queues for. If -1, skip flushing write queues. </td></tr>
    <tr><td class="paramname">read</td><td>Whether to flush the incoming read queue as well. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a404220bc4f248e5655b964667a14ad34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a404220bc4f248e5655b964667a14ad34">&#9670;&nbsp;</a></span>get_mode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int smu::Device::get_mode </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the mode of the specified channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>An unsigned integer relating to the requested channel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The mode of the specified channel. </dd>
<dd>
On error, a negative integer is returned relating to the error status. </dd></dl>

</div>
</div>
<a id="a65a4d09c13f1b16453db49d919f79904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a4d09c13f1b16453db49d919f79904">&#9670;&nbsp;</a></span>off()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int smu::Device::off </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop any current sample writes and stop capturing samples. </p>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned. </dd>
<dd>
On error, a negative errno code is returned. </dd></dl>

</div>
</div>
<a id="a268a9b03f25704e7026841a74c468759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a268a9b03f25704e7026841a74c468759">&#9670;&nbsp;</a></span>on()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int smu::Device::on </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turn on power supplies and clear sampling state. </p>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned. </dd>
<dd>
On error, a negative errno code is returned. </dd></dl>

</div>
</div>
<a id="af193dd5fee8276d148d495e55de7891e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af193dd5fee8276d148d495e55de7891e">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ssize_t smu::Device::read </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::array&lt; float, 4 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipsamples</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all signal samples from a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Buffer object to store sample values into. </td></tr>
    <tr><td class="paramname">samples</td><td>Number of samples to read. </td></tr>
    <tr><td class="paramname">timeout</td><td>Amount of time in milliseconds to wait for samples. </td></tr>
    <tr><td class="paramname">skipsamples</td><td>Whether to skip the queued samples. to be available. If 0 (the default), return immediately. If -1, block indefinitely until the requested number of samples is available. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the number of samples read. </dd>
<dd>
On error, a negative integer is returned relating to the error status. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::system_error</td><td>of EBUSY if sample overflows have occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3b93ae4bd2c06866ee922f005093e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3b93ae4bd2c06866ee922f005093e50">&#9670;&nbsp;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int smu::Device::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classsmu_1_1Device.html" title="Generic device class.">Device</a> releasing when a session removes this device. </p>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned. </dd>
<dd>
On error, a negative errno code is returned. </dd></dl>

</div>
</div>
<a id="af75d9c8f05d40317c001a37181f09750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af75d9c8f05d40317c001a37181f09750">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int smu::Device::run </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>samples</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make the device start sampling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">samples</td><td>Number of samples to run before stopping. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned. </dd>
<dd>
On error, a negative errno code is returned. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::system_error</td><td>of EBUSY if sample underflows/overflows have occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaebb9455a2699d5f8dd38209291a67ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaebb9455a2699d5f8dd38209291a67ba">&#9670;&nbsp;</a></span>samba_mode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int smu::Device::samba_mode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force the device into SAM-BA bootloader mode. </p>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned. </dd>
<dd>
On error, a negative errno code is returned. </dd></dl>

</div>
</div>
<a id="a447cf709dfe1f5a596457cf45396e0ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447cf709dfe1f5a596457cf45396e0ad">&#9670;&nbsp;</a></span>set_led()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int smu::Device::set_led </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>leds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the leds states for device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leds</td><td>value between [0, 7], each bit of the value represents the state of an LED (1-on 0-off) in this order (RGB or DS3,DS2,DS1 on rev F hardware) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a07260d2717082aa4ac21f2c8552a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a07260d2717082aa4ac21f2c8552a2e">&#9670;&nbsp;</a></span>set_mode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int smu::Device::set_mode </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>restore</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the mode of the specified channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>An unsigned integer relating to the requested channel. </td></tr>
    <tr><td class="paramname">mode</td><td>An unsigned integer relating to the requested mode. </td></tr>
    <tr><td class="paramname">restore</td><td>Boolean relating to supporting saving the mode being </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned. </dd>
<dd>
On error, a negative integer is returned relating to the error status. This method may not be called while the session is active. </dd></dl>

</div>
</div>
<a id="ac77ee34515d91d93ccbcd88afbb99641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77ee34515d91d93ccbcd88afbb99641">&#9670;&nbsp;</a></span>set_serial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int smu::Device::set_serial </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>serial</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a custom serial number for the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serial</td><td>The custom serial number to set, defaults to an empty string that causes the device to reset back to its original serial number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned. </dd>
<dd>
On error, a negative integer is returned relating to the error status. This method may not be called while the session is active. </dd></dl>

</div>
</div>
<a id="a4ecee69bc241b53855debf994abb6575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ecee69bc241b53855debf994abb6575">&#9670;&nbsp;</a></span>signal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classsmu_1_1Signal.html">Signal</a>* smu::Device::signal </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>signal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the specified signal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>An unsigned integer relating to the requested channel. </td></tr>
    <tr><td class="paramname">signal</td><td>An unsigned integer relating to the requested signal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The related <a class="el" href="classsmu_1_1Signal.html" title="Generic signal class.">Signal</a>. </dd></dl>

</div>
</div>
<a id="a3011b5d22927b5ff4e3dc6167c6aa8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3011b5d22927b5ff4e3dc6167c6aa8bf">&#9670;&nbsp;</a></span>sync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int smu::Device::sync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare multi-device synchronization. Get current microframe index, set m_sof_start to be time in the future. </p>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned. </dd>
<dd>
On error, a negative errno code is returned. </dd></dl>

</div>
</div>
<a id="a30e43c4c950d69c406ea8e3f7c8a360f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30e43c4c950d69c406ea8e3f7c8a360f">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int smu::Device::write </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cyclic</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data to a specified channel of the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Buffer of samples to write to the specified channel. </td></tr>
    <tr><td class="paramname">channel</td><td>Channel to write samples to. </td></tr>
    <tr><td class="paramname">cyclic</td><td>Enable cyclic mode (passed buffer is looped over continuously). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned. </dd>
<dd>
On error, a negative integer is returned relating to the error status. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::system_error</td><td>of EBUSY if sample underflows have occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a036087f31acc01c3f617005c42d71087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036087f31acc01c3f617005c42d71087">&#9670;&nbsp;</a></span>write_calibration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int smu::Device::write_calibration </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cal_file_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the device calibration data into the EEPROM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cal_file_name</td><td>The path to a properly-formatted calibration data file to write to the device. If NULL is passed, calibration is reset to the default setting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned. </dd>
<dd>
On error, a negative integer is returned relating to the error status. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af0c14565874163ac3fda5a719890da3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0c14565874163ac3fda5a719890da3e">&#9670;&nbsp;</a></span>m_overcurrent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int smu::Device::m_overcurrent = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classsmu_1_1Session.html" title="Generic session class.">Session</a> this device is associated with. </p>
<p>Overcurrent status for the most recent data request. Is 1 if an overcurrent event occurred in the most recent data request, 0 otherwise. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/vsts/work/1/s/include/libsmu/<a class="el" href="libsmu_8hpp_source.html">libsmu.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 11 2022 13:51:01 for libsmu by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
