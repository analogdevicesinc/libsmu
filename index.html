<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libsmu: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libsmu
   &#160;<span id="projectnumber">1.0.3-gf34bc49</span>
   </div>
   <div id="projectbrief">Library for interfacing with ADALM1000 devices</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">libsmu Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#building">Building and installing libsmu</a><ul><li class="level2"><a href="#install_linux">Linux</a></li>
<li class="level2"><a href="#install_linux_py">Python bindings for Linux</a></li>
<li class="level2"><a href="#install_macos">MacOS</a></li>
<li class="level2"><a href="#install_deps_linux">Install Dependencies</a></li>
<li class="level2"><a href="#install_deps_macos">Install Dependencies</a></li>
<li class="level2"><a href="#clone_configure_build">Clone, configure and build</a></li>
<li class="level2"><a href="#install_step">Install</a></li>
</ul>
</li>
<li class="level1"><a href="#devices">Device usage</a><ul><li class="level2"><a href="#general_information">General information about libsmu usage</a></li>
<li class="level2"><a href="#reading_data">Reading data from a device</a></li>
<li class="level2"><a href="#writing_data">Writing data to a device</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="building"></a>
Building and installing libsmu</h1>
<p>libsmu contains abstractions for streaming data to and from USB-connected analog interface devices, currently supporting the Analog Devices' ADALM1000. Building off of LibUSB for cross-platform operation, it offers the sourcing of repeated waveforms, configuration of hardware, and measuring of signals.</p>
<p>Python bindings are also provided in the form of the pysmu module. See instructions below for how to build them.</p>
<h1>Simple installation</h1>
<h2><a class="anchor" id="install_linux"></a>
Linux</h2>
<p>Download the specific libsmu .deb package for your Linux distribution from the Releases section. Currently we are supporting Ubuntu 16, 18 and 20. The package name should start with libsmu and contain the OS version. Go to the folder you downloaded the package in and open a terminal, then run the following command: </p><div class="fragment"><div class="line">analog@analog:~$ sudo apt install -f ./&lt;libsmu_package_name&gt;.deb</div></div><!-- fragment --><h2><a class="anchor" id="install_linux_py"></a>
Python bindings for Linux</h2>
<p>If you want to install pysmu (the Python bindings for libsmu), you can download the specific .deb package. Currently we are supporting the default Python versions for each Ubuntu version (3.5 for Ubuntu 16, 3.6 for Ubuntu 18, 3.8 for Ubuntu 20). The package name should start with python3 and contain the OS version. These packages contain the Python bindings for libsmu. Go to the folder you downloaded the package in and open a terminal, then run the following command: </p><div class="fragment"><div class="line">analog@analog:~$ sudo apt install -f ./&lt;python_package_name&gt;.deb</div></div><!-- fragment --><h2><a class="anchor" id="install_macos"></a>
MacOS</h2>
<p>Download the specific libsmu .pkg package for your MacOS distribution from the Releases section. Currently we are supporting MacOS 10.13, 10.14 and 10.15. The package name should start with libsmu and contain the MacOS version.</p>
<p>Open a terminal and run the following command which will install only the base library in /Library/Frameworks. </p><div class="fragment"><div class="line">analog@analog:~$ sudo installer -pkg /path/to/&lt;libsmu_package_name&gt;.pkg -target /</div></div><!-- fragment --><p>A different way to install libsmu on MacOS is by using the .tar.gz located in the Releases section. This will install the .dylib (libraries) into system paths (usr/local) and it will also install the smu CLI. </p><div class="fragment"><div class="line">tar -xzvf &lt;libsmu_package_name&gt;.tar.gz --strip=3 -C /usr/local</div></div><!-- fragment --><p> Based on this base library installation, you can install the Python bindings manually for the desired Python version. Check the <b>Python</b> section below.</p>
<h1>Build instructions for libsmu on Linux</h1>
<h2><a class="anchor" id="install_deps_linux"></a>
Install Dependencies</h2>
<p>Install prerequisites </p><div class="fragment"><div class="line">analog@analog:~$ sudo apt-get update</div><div class="line">analog@analog:~$ sudo apt-get install libusb-1.0-0-dev libboost-all-dev cmake pkgconfig</div></div><!-- fragment --><p> Install to build Python bindings </p><div class="fragment"><div class="line">analog@analog:~$ sudo apt-get install python3 python3-setuptools python3-pip</div><div class="line">analog@analog:~$ pip3 install --upgrade pip</div><div class="line">analog@analog:~$ sudo pip3 install cython</div></div><!-- fragment --><p> Install to build documentation </p><div class="fragment"><div class="line">analog@analog:~$ sudo apt-get install doxygen</div></div><!-- fragment --><h1>Build instructions for libsmu on MacOS</h1>
<h2><a class="anchor" id="install_deps_macos"></a>
Install Dependencies</h2>
<p>Install prerequisites </p><div class="fragment"><div class="line">analog@analog:~$ brew update</div><div class="line">analog@analog:~$ brew install libusb cmake pkg-config boost</div><div class="line">(optional) analog@analog:~$ brew link --overwrite boost</div></div><!-- fragment --><p> Install to build Python bindings </p><div class="fragment"><div class="line">analog@analog:~$ brew install python3</div><div class="line">analog@analog:~$ pip3 install --upgrade pip</div><div class="line">analog@analog:~$ pip3 install cython</div></div><!-- fragment --><p> Setup tools and pip should be included in the "python3" package.</p>
<p>Install to build documentation </p><div class="fragment"><div class="line">analog@analog:~$ brew install doxygen</div></div><!-- fragment --><h2><a class="anchor" id="clone_configure_build"></a>
Clone, configure and build</h2>
<div class="fragment"><div class="line">analog@analog:~$ git clone https://github.com/analogdevicesinc/libsmu.git</div><div class="line">analog@analog:~$ cd libsmu </div></div><!-- fragment --><p> Options: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">CMake Options  </th><th class="markdownTableHeadNone">Default  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>BUILD_CLI</code>  </td><td class="markdownTableBodyNone">ON  </td><td class="markdownTableBodyNone">Build command line smu application   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>BUILD_PYTHON</code>  </td><td class="markdownTableBodyNone">ON  </td><td class="markdownTableBodyNone">Build python bindings   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>WITH_DOC</code>  </td><td class="markdownTableBodyNone">OFF  </td><td class="markdownTableBodyNone">Generate documentation with Doxygen and Sphinx   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>BUILD_EXAMPLES</code>  </td><td class="markdownTableBodyNone">OFF  </td><td class="markdownTableBodyNone">Build examples   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>USE_PYTHON2</code>  </td><td class="markdownTableBodyNone">ON  </td><td class="markdownTableBodyNone">By default, CMake will search for Python 2 or 3. If USE_PYTHON2 is set to OFF, then only Python3 will be used.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>INSTALL_UDEV_RULES</code>  </td><td class="markdownTableBodyNone">ON  </td><td class="markdownTableBodyNone">Install a udev rule for detection of USB devices   </td></tr>
</table>
<p>Configure via cmake: </p><div class="fragment"><div class="line">analog@analog:~$ mkdir build &amp;&amp; cd build</div><div class="line">analog@analog:~$ cmake .. -DBUILD_PYTHON=ON</div></div><!-- fragment --><p>Compile: </p><div class="fragment"><div class="line">analog@analog:~$ make</div></div><!-- fragment --><h2><a class="anchor" id="install_step"></a>
Install</h2>
<p>If <b>-DBUILD_PYTHON=ON</b> (from the above options) is specified, this step will also install the Python Bindings using the Python version detected at the CMake configuration step. </p><div class="fragment"><div class="line">analog@analog:~$ sudo make install</div></div><!-- fragment --><h1>Testing</h1>
<p>The <a href="https://github.com/google/googletest">Google Test framework</a> is used to run various streaming tests. Make sure it's installed on the host system and then use the following to build and run tests:</p>
<div class="fragment"><div class="line">analog@analog:~$ cmake -DBUILD_TESTS=ON ..</div><div class="line">analog@analog:~$ make check</div></div><!-- fragment --><p>Note that at least one device should be inserted to the system for the checks to run properly.</p>
<h1>Python Bindings</h1>
<p>Python Bindings are enabled by default and can be disabled using the CMake option mentioned above.</p>
<p>Note that this will build only one version of Python for the first supported implementation it finds installed on the system. To build them for other versions it's easiest to build them manually via the setup.py script in the regular python manner if libsmu has already been built and/or installed on the host machine.</p>
<div class="fragment"><div class="line">analog@analog:~$ git clone https://github.com/analogdevicesinc/libsmu.git</div><div class="line">analog@analog:~$ cd libsmu/bindings/python</div><div class="line">analog@analog:~$ python3 setup.py build</div><div class="line">analog@analog:~$ sudo python3 setup.py install</div></div><!-- fragment --><h1>Linux FAQ</h1>
<p>By default, libsmu is installed into various directories inside /usr/local which implies that the runtime linker cache often needs to be regenerated, otherwise runtime linking errors will occur.</p>
<p>Regenerate runtime linker cache after install: </p><div class="fragment"><div class="line">analog@analog:~$ sudo ldconfig</div></div><!-- fragment --><p>If the same errors still happen, make sure the directory the libsmu library is installed to is in the sourced files for /etc/ld.so.conf before running ldconfig.</p>
<p>In addition, the udev rules file (53-adi-m1k-usb.rules) is installed by default to give regular users access to devices supported by libsmu. Udev has to be forced to reload its rules files in order to use the new file without rebooting the system.</p>
<p>Reload udev rules files: </p><div class="fragment"><div class="line">analog@analog:~$ sudo udevadm control --reload-rules</div></div><!-- fragment --><p>Finally, for python support on Debian/Ubuntu derived distros users will have to export PYTHONPATH or perform a similar method since hand-built modules are installed to the site-packages directory (which isn't in the standard search list) while distro provided modules are placed in dist-packages.</p>
<p>Add pysmu module directory to python search path: </p><div class="fragment"><div class="line">$ export PYTHONPATH=/usr/local/lib/python3.7/site-packages:${PYTHONPATH}</div></div><!-- fragment --><p>Note the command will have to be altered for targets with different bitness or python versions.</p>
<h1>Windows</h1>
<p>On Windows, it's easiest to use the provided installers, <a href="https://github.com/analogdevicesinc/libsmu/releases/latest">libsmu-setup-x86.exe</a> and <a href="https://github.com/analogdevicesinc/libsmu/releases/latest">libsmu-setup-x64.exe</a> that install either 32 or 64 bit support, respectively. During the install process options are provided to install drivers, Python bindings and Visual Studio development support.</p>
<h1><a class="anchor" id="devices"></a>
Device usage</h1>
<h2><a class="anchor" id="general_information"></a>
General information about libsmu usage</h2>
<p>The most important classes from libsmu are Session and Device. Device is controlling a specific M1k device, while Session is controlling all currently connected devices.</p>
<p>The most important members of these classes are:</p><ul>
<li>Session:<ul>
<li>add(Device* device): connects the given device to the current Session.</li>
<li>add_all(): connects all plugged in devices to the current Session.</li>
<li>m_devices: set containing the currently connected devices.</li>
<li>run(uint64_t num_samples): generates num_samples samples on all connected devices. If num_samples == 0, it will run in a continuous fashion.</li>
<li>start(uint64_t num_samples): configures the devices before generating the requested number of samples. It is internally called by run().</li>
<li>cancel(): cancels all currently pending transfers from all devices.</li>
<li>end(): completes the currently active transfers before ending the Session. If the session was running in a continuous fashion, it also cancels the pending transfers.</li>
<li>flush(): deletes all the previously generated samples for all connected devices.</li>
</ul>
</li>
<li>Device:<ul>
<li>m_serial: the device's serial number.</li>
<li>m_fwver: the device's firmware version.</li>
<li>read(vector&lt;array&lt;float, 4&gt;&gt; buf, size_t num_samples, int timeout, bool skipsamples): reads num_samples samples from the current device and stores them in buf. It waits up to timeout milliseconds for new samples (if timeout == -1, it waits undefinetly). Skips the oldest samples if more than requested are available. Timeout defaults to 0 and skisamples to false.</li>
<li>write(vector&lt;array&lt;float, 4&gt;&gt; buf, unsigned channel, bool cyclic): writes buf to the given channel (0 for channel A, 1 for channel B). If cyclic == true it writes the buffer continuously. cyclic defaults to false.</li>
<li>run(uint64_t samples): similar to Session.run(), but only for the current device.</li>
<li>flush(int channel, bool read): deletes all the previously generated samples from the specified channel. If read == true, it also deletes the incoming read queue; defaults to false.</li>
<li>set_mode(unsigned channel, unsigned mode, bool restore): sets the specified mode to the specified channel (0 - channel A, 1 - channel B). The available modes are: Mode.HI_Z (0; channel is floating), Mode.SVMI (1; source voltage, measure current), Mode.SIMV (2; source current, measure voltage), Mode.HI_Z_SPLIT (3; HI_Z with enabled switch for the input only pin added in Rev F), Mode.SVMI_SPLIT (4; SVMI with enabled switch for the input only pin added in Rev F) and Mode.SIMV_SPLIT (5; SIMV with enabled switch for the input only pin added in Rev F).</li>
</ul>
</li>
</ul>
<p>You can find libsmu's complete public API in the Classes menu. <br />
 On the main github page you can find various examples using libsmu. <br />
 In the following sections we will present you in detail the reading and writing processes using libsmu.</p>
<h2><a class="anchor" id="reading_data"></a>
Reading data from a device</h2>
<object type="image/svg+xml" data="img/reading.svg" alt="Caption text"></object>
/>
<div class="fragment"><div class="line">    <span class="comment">// Create session object and add all compatible devices them to the</span></div><div class="line">    <span class="comment">// session. Note that this currently doesn&#39;t handle returned errors.</span></div><div class="line">    Session* session = <span class="keyword">new</span> Session();</div><div class="line">    session-&gt;add_all();</div><div class="line"></div><div class="line">    <span class="comment">// Grab the first device from the session (we&#39;re assuming one exists).</span></div><div class="line">    <span class="keyword">auto</span> dev = *(session-&gt;m_devices.begin());</div><div class="line"></div><div class="line">    <span class="comment">// Run session at the default device rate.</span></div><div class="line">    session-&gt;configure(dev-&gt;get_default_rate());</div><div class="line">    <span class="comment">// Run session in continuous mode.</span></div><div class="line">    session-&gt;start(0);</div><div class="line"></div><div class="line">    <span class="comment">// Data to be read from the device is formatted into a vector of four</span></div><div class="line">    <span class="comment">// floats in an array, specifically in the format</span></div><div class="line">    <span class="comment">// &lt;Chan A voltage, Chan A current, Chan B coltage, Chan B current&gt;.</span></div><div class="line">    std::vector&lt;std::array&lt;float, 4&gt;&gt; buf;</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div><div class="line">        <span class="keywordflow">try</span> {</div><div class="line">            <span class="comment">// Read 1024 samples at a time from the device.</span></div><div class="line">            <span class="comment">// Note that the timeout (3rd parameter to read() defaults to 0</span></div><div class="line">            <span class="comment">// (nonblocking mode) so the number of samples returned won&#39;t</span></div><div class="line">            <span class="comment">// necessarily be 1024.</span></div><div class="line">            dev-&gt;read(buf, 1024);</div><div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::system_error&amp; e) {</div><div class="line">            <span class="comment">// Ignore sample drops which will occur due to the use of printf()</span></div><div class="line">            <span class="comment">// which is slow when attached to a terminal.</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// Iterate over all returned samples, doesn&#39;t have to be 1024).</span></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> i: buf) {</div><div class="line">            printf(<span class="stringliteral">&quot;Channel A: Voltage %f Current %f\n&quot;</span>, i[0], i[1]);</div><div class="line">            printf(<span class="stringliteral">&quot;Channel B: Voltage %f Current %f\n&quot;</span>, i[2], i[3]);</div><div class="line">        }</div><div class="line">    };</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="writing_data"></a>
Writing data to a device</h2>
<object type="image/svg+xml" data="img/writing.svg" alt="Caption text"></object>
/>
<div class="fragment"><div class="line">    <span class="comment">// Create session object and add all compatible devices them to the</span></div><div class="line">    <span class="comment">// session. Note that this currently doesn&#39;t handle returned errors.</span></div><div class="line">    Session* session = <span class="keyword">new</span> Session();</div><div class="line">    session-&gt;add_all();</div><div class="line"></div><div class="line">    <span class="comment">// Grab the first device from the session (we&#39;re assuming one exists).</span></div><div class="line">    <span class="keyword">auto</span> dev = *(session-&gt;m_devices.begin());</div><div class="line"></div><div class="line">    <span class="comment">// Run session at the default device rate.</span></div><div class="line">    session-&gt;configure(dev-&gt;get_default_rate());</div><div class="line">    <span class="comment">// Run session in continuous mode.</span></div><div class="line">    session-&gt;start(0);</div><div class="line"></div><div class="line">    <span class="comment">// Data to be written to the device is formatted into a vector of floats.</span></div><div class="line">    <span class="comment">// Both channels can be written to simultaneously depending on what mode</span></div><div class="line">    <span class="comment">// they&#39;re currently in.</span></div><div class="line">    std::vector&lt;float&gt; buf1;</div><div class="line">    std::vector&lt;float&gt; buf2;</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div><div class="line">        <span class="comment">// Generic function to grab new data to write to the device.</span></div><div class="line">        refill_data(buf1);</div><div class="line">        refill_data(buf2);</div><div class="line"></div><div class="line">        <span class="comment">// Write data channel A of the device.</span></div><div class="line">        <span class="comment">// Note that the timeout (3rd parameter to write() defaults to 0 (nonblocking mode).</span></div><div class="line">        dev-&gt;write(buf1, 0);</div><div class="line">        <span class="comment">// Write data to channel B of the device.</span></div><div class="line">        dev-&gt;write(buf2, 1);</div><div class="line"></div><div class="line">        <span class="keywordflow">try</span> {</div><div class="line">            <span class="comment">// Read 1024 samples at a time from the device.</span></div><div class="line">            <span class="comment">// Note that the timeout (3rd parameter to read() defaults to 0</span></div><div class="line">            <span class="comment">// (nonblocking mode) so the number of samples returned won&#39;t</span></div><div class="line">            <span class="comment">// necessarily be 1024.</span></div><div class="line">            dev-&gt;read(buf, 1024);</div><div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::system_error&amp; e) {</div><div class="line">            <span class="comment">// Ignore sample drops which will occur due to the use of printf()</span></div><div class="line">            <span class="comment">// which is slow when attached to a terminal.</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// Iterate over all returned samples, doesn&#39;t have to be 1024).</span></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> i: buf) {</div><div class="line">            printf(<span class="stringliteral">&quot;Channel A: Voltage %f Current %f\n&quot;</span>, i[0], i[1]);</div><div class="line">            printf(<span class="stringliteral">&quot;Channel B: Voltage %f Current %f\n&quot;</span>, i[2], i[3]);</div><div class="line">        }</div><div class="line">    };</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 1 2020 06:50:18 for libsmu by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
